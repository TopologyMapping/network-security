# Authentication_ZAP_GT_CRIVO

This framework was designed to automate the process of security testing in web applications, utilizing authentication to expand the attack surface. It allows the user to test multiple applications without the need to interact directly with the application's content. The framework automates the process of metadata capture, extraction of key elements, and authentication within the applications. After authentication, the framework processes the metadata and generates a web application configuration file that can later be used for security testing.

## ZAP

The Zed Attack Proxy (ZAP) is a tool used for security testing in web applications. The framework uses a Docker image of ZAP, which includes a proxy and an API running on port 8080. The main idea is to connect the framework to the ZAP proxy at the moment a web application is instantiated. This way, ZAP analyzes the application using both passive and active scans during security tests.

The framework interacts with ZAP by sending commands and receiving data through the API. The necessary data to create the application's context file is extracted from the alerts generated by ZAP, which indicate potential vulnerabilities. These alerts are configured to require evidence when triggered, which can be provided by the user or the tool's developers. In this version, the framework uses the alerts defined by ZAP's own developers.

### Context

A context is metadata of an application that can be used to perform security tests. This metadata may include information such as user credentials to be used for authentication, details about the application's session management, data on the type of authentication requests the application supports, URLs associated with the application to be tested, URLs to be excluded from testing, and technologies to be covered during the tests. 

A context can be named and saved in a file format, which can later be instantiated for future vulnerability tests on the same application.

### Automate plan

An automation plan is a YAML file that uses the context metadata to perform actions beyond just creating the mentioned file. In addition to generating the context file, the plan can also define jobs to create an automated execution pipeline, eliminating the need for the user to manually import the file into the tool and select the desired type of test. This plan enables the inclusion of various types of vulnerability test executions in ZAP, covering all preliminary tests on a web application in an automated manner.

The developed framework generates the automation plan with some predefined jobs so that, by using this automation file, the user can either generate the file based on the context or perform a full scan.

## Framework

The framework connects to the ZAP API to perform tests and capture metadata. Initially, it checks for the existence of configuration files in the designated volume directory. Once identified, the execution flow begins. Each configuration file is parsed, and its fields are interpreted using the Pydantic library. If a file does not contain the essential information defined in the configuration class, it will be disregarded.

The code is organized into modules, and the process for each of them will be explained below.

### Authentication

The `authentication.py` module contains functions to locate and validate elements on a web page based on specific attributes. Additionally, it verifies the presence of credentials in the request body of an authentication request.

The `find_element_by_attribute` function is used to locate an element on a web page based on a specified attribute. It accepts three arguments: `driver`, which is the instance of Selenium WebDriver; `attribute`, the attribute to search for (e.g., "name," "type," "placeholder"); and `value`, the value of the attribute to look for. The function attempts to find the corresponding element and returns the found element (`WebElement`) if it exists, or `None` if the element is not found. If the specified attribute is invalid, the function raises a `ValueError`.

The `validate_by_attribute` function validates whether an element with the specified attribute and value is visible on the page. The function attempts to find the corresponding element and checks if it is visible on the page. If the element is found and visible, the function logs a failure message for login, refreshes the page to clear partially found credentials, and returns `False`. If the element is not found, the function logs a success message for login and returns `True`.

The `check_credentials` function receives a request string and two credentials (login and password) and verifies if both credentials are present in the request body. If the login and password credentials are identical, the function checks if the credential appears at least twice in the string, indicating that the login and password are the same. Otherwise, the function checks if both credentials are present in the string. The function returns `True` if the credentials are found as expected, or `False` otherwise.

### Context

The `replace_words` function is responsible for replacing login and password keywords with the default credentials accepted by ZAP. It takes as arguments the text to be modified, the login and password to be replaced, and the default credentials (`credential_login` and `credential_password`). The function handles a special case where `%40` is replaced by `@`, as observed in some tests where requests using `@` were returned with it replaced by `%40`. If the login and password are identical, the function replaces the first occurrence of both with the default credentials. Otherwise, if `%40` is present in the text, the login is modified by substituting `@` with `%40` before making the replacement. The function returns the modified text, which is the standard input for ZAP.

The `build_yaml` function takes context information as parameters and constructs the YAML file responsible for the application's automation plan. Parameters include the context, alert count, request body, login and password credentials, the name of the file to be generated with the context, the base URL, and the base login URL. If the alert count is greater than zero, the function sets the application's session management to auto-detection for context creation. Afterward, the `replace_words` function is called to replace the login and password keywords in the request body with the default credentials. The modified request body is then used to update the YAML context.

The `update_jobs` function is used to update the automation plan file with jobs that can be manually specified by the user, such as Spider, Ajax Spider, Full Scan, and other functionalities provided by ZAP.

### Keywords
#### elements


The `elements.py` module contains functions for identifying password fields in web page elements and for filtering page elements based on evidence of authentication forms.

The `find_password` function is used to check whether an element in a form contains a password field. It takes an element as an argument and uses a regular expression to determine if any value of the element matches a password pattern. The function returns True if a password field is found; otherwise, it returns False.

The `filtered_dict` function takes a page instance, a page potentially containing an authentication form, and an empty structure to be populated. It extracts all elements from the page and uses regular expressions to verify if the elements are authentication fields. The function filters these page elements and returns a dictionary with the filtered elements.

The function operates in a loop, which means that multiple non-candidate pages may exist in the queue. Because of this, the page does not use the ZAP proxy. Consequently, the driver is closed as soon as the elements are extracted. If no elements are found initially, the function attempts to find elements again after sending the ESCAPE key to handle potential pop-ups. The elements found are then added to a list, array_elements, which is populated with information about the elements' attributes, such as name, type, placeholder, and id.

#### keywords

The `keywords.py` module contains the `RegexSets` class, which is responsible for loading regular expression files that will be used to identify elements on a page. The `RegexSets` class includes methods to load and read these files, as well as to store the loaded regular expression sets.

The `RegexSets` class is initialized with the path to the folder where the regex files are located. The `__init__` method sets the folder path and calls the `load_files` method to load the regex files. The `load_files` method retrieves all `.txt` files in the specified folder, sorts them, and reads them using the `read_files` method. For each file, the key is set as the file name (excluding the extension), and the file's content is stored in the `keywords` dictionary. The loaded regex sets are then assigned to specific class attributes: `invalid_values_urls`, `type_elements`, `valid_values_elements`, and `url_words`.

The `read_files` method is responsible for reading the content of a text file. It takes the file name as an argument, opens the file, and reads each line, removing any extra whitespace. The method returns a list of lines read from the file.

In addition to the `RegexSets` class, the module defines some global variables:
- **`password_field_identifiers`**: A tuple containing identifiers for password fields.
- **`parameters_types`**: A tuple containing parameter types (`form` and `json`).
- **`parameter_types_found`**: A dictionary that tracks the count of parameter types found (`form`, `json`, and `script`).


### Params

The `define_authentication_type` function is responsible for determining the authentication type based on the application's request body. It takes as arguments an instance of ZAP, the `requestbody`, and the login and password credentials. 

The function checks if the request body contains the login and password credentials and, based on this, sets the authentication type to either `form` or `json`. If the credentials are present in the request body, the function sets the authentication type to `form`. Otherwise, it sets it to `json`.

### Urls_Login

The `find_urls_login` function takes two lists as parameters: `list_of_strings` and `list_of_words`. It iterates over each string in the `list_of_strings`, and for each string, it iterates over each word in the `list_of_words`. If a word is found within the string, the string is added to a results list called `found_urls`, and the inner iteration is terminated. 

At the end, the function returns the `found_urls` list, which contains all the strings that include at least one of the words from the `list_of_words`.

### User_data

The `user_data` module contains the class responsible for parsing the JSON provided by the user to perform authentication and application identification during testing with ZAP.

### **Configuration in `user_data.py`**

The `Configuration` class is a subclass of Pydantic's `BaseModel`, used to parse a JSON file that the user must provide with application data to enable automation. The class includes the following attributes:

- **`context`**: A string representing the title of the configuration, which will be imported as the testing context for the application.
- **`url`**: A list of strings containing the URLs related to the configuration.
- **`url_login`**: An optional string representing the login URL. If the user provides this login URL, the automation will use it. Otherwise, the module will perform a heuristic search to find the URL with the authentication form.
- **`exclude_urls`**: A list of strings containing URLs to be excluded. The default value is an empty list.
- **`report_title`**: An optional string representing the title of the ZAP test report. The default value is `"Report"`.
- **`login`**: A string representing the user's login.
- **`password`**: A string representing the user's password.

This class structures the necessary information for conducting tests through ZAP.

## configuration file

The configuration file must be in JSON format. Below is an real example:

```json
    context: "context_bWAPP"
    url: "192.168.15.3/bWAPP/"
    url_login: "192.168.15.3/bWAPP/login"
    exclude_urls: []
    report_title: "Report_bWAPP"
    login: "admin"
    password: "admin"
```

Pydantic will parse the file and extract the necessary attributes for creating the context. An example will be provided in the root of the repository, named `example.json`.

## Main

The `main.py` file is responsible for orchestrating the entire process of security test automation in web applications. It performs various steps, from reading and validating the user's configuration to generating a YAML context file for ZAP (Zed Attack Proxy). The `main` function has several responsibilities.

The main module reads the JSON configuration file provided by the user and validates the JSON using the `Configuration` class from the `user_data` module. After that, it sets up variables and initializes ZAP by loading regular expressions using the `RegexSets` class from the `keywords` module, setting the required environment variables such as `FIREFOX` and `ZAP_API_KEY`, and starting a new ZAP session using the `zapv2` library. 

Selenium is also configured in the main module, setting up Firefox to use ZAP's proxy and ignoring certificate errors. A Firefox profile is defined to use ZAP's proxy.

The module checks whether a login URL was provided by the user. If the URL is not provided, the module performs a scan with ZAP's spider to find potential login URLs using the `spider_scan` function. When a URL with an authentication form is found, the module instantiates the `filtered_dict` function from the `elements` module to extract and filter authentication elements from the login page. After creating the structure to perform the login, the main module submits the login credentials to the identified authentication fields and validates whether the login was successful using the `validate_by_attribute` function from the `autentication` module.

After authentication is completed by instantiating the WebDriver with ZAP's proxy, the module captures alerts generated by ZAP during the authentication process, verifies whether the credentials were sent correctly using the `check_credentials` function from the `autentication` module, defines the type of authentication based on the request body using the `Define_authentication_type` function from the `params` module, constructs the YAML context file using the `build_yaml` function from the `context` module, and updates the jobs in the YAML file using the `update_jobs` function from the `context` module. Finally, the configuration is saved to a YAML file that is generated in the shared directory.

## Docker Compose

The `docker-compose` was configured to allow the two applications to interact with each other. A *bridge* mode subnet was created, and dependencies between the containers were defined to ensure the correct execution order. First, the ZAP container is started, followed by the framework container.

## Makefile

The `Makefile` performs important operations for the proper functioning of the framework:

1. Generates the API key to be used by ZAP, setting it as an environment variable (the key is randomly generated with each execution).
2. Executes the `copy.sh` script, which copies the configuration files from the specified directory to the framework's volume.

### copy.sh


This script takes the configuration files' directory as a parameter and copies them to the volume, avoiding duplications with each execution. Only `.json` files are copied, and if any file fails the Pydantic parser, it will be ignored.

## Input

Before starting the framework, it is necessary to create a configuration file for the application to be tested, as shown above. After creating one or more configuration files, store them in a single directory, whose path will be used as a parameter for the `Makefile`.

## Output

The framework generates a YAML file with the plan for passive scans and the application's context.

## How to use

To start the framework, use the command:

```bash
make run DIR="directory of the files"
```

The `docker-compose` will bring up two containers: ZAP and the framework. The containers run in the *background*. To view the logs, use the commands:

```bash
docker logs -f authentication_zap_gt_crivo-zaproxy-1
docker logs -f authentication_zap_gt_crivo-framework-1
```

The framework application can be managed using the command:

```bash
docker exec -it authentication_zap_gt_crivo-framework-1 /bin/bash
```

All information related to the configuration files or the automation plans that are generated is located in the `shared_data` folder at the root of the application's compose.

To stop the application, use: 

```bash
docker compose down
```
