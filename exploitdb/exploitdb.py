from __future__ import annotations

import codecs
import csv
import datetime
import logging
import pathlib
import time
from typing import Optional

import pydantic
import requests

DEFAULT_EXPLOITDB_CSV_URL = (
    "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"
)


class Exploit(pydantic.BaseModel):
    eid: int
    file: str
    description: str
    date_published: datetime.date
    author: str
    etype: str
    platform: str
    port: Optional[str]
    date_added: datetime.date
    date_updated: Optional[datetime.date]
    verified: bool
    codes: list[str]
    tags: Optional[str]
    aliases: Optional[str]
    screenshot_url: Optional[str]
    application_url: Optional[str]
    source_url: Optional[str]

    @staticmethod
    def parse_row(row: dict) -> Exploit:
        row = {k: v or None for k, v in row.items()}
        row["eid"] = row["id"]
        row["etype"] = row["type"]
        row["codes"] = list(row["codes"].split(";")) if row["codes"] else []
        return Exploit(**row)


def _load_from_iterator(iterator) -> dict[int, Exploit]:
    eid2exploit = {}
    start_timestamp = time.time()
    for i, row in enumerate(csv.DictReader(iterator)):
        exploit = Exploit.parse_row(row)
        eid2exploit[exploit.eid] = exploit
    runtime = time.time() - start_timestamp
    logging.info("Imported %d ExploitDB records in %.3f seconds", i + 1, runtime)
    return eid2exploit


def load_from_csv(fn: pathlib.Path) -> dict[int, Exploit]:
    logging.info("Importing ExploitDB CSV from %s", fn)
    with open(fn, encoding="utf8") as fd:
        return _load_from_iterator(fd)


def load_from_url(url: str = DEFAULT_EXPLOITDB_CSV_URL) -> dict[int, Exploit]:
    logging.info("Importing ExploitDB CSV from %s", url)
    response: requests.Response = requests.get(url, stream=True)
    if response.status_code != 200:
        logging.error("Failed to download ExploitDB CSV, aborting")
        logging.info("ExploitDB URL: %s", url)
        logging.info("HTTP status: %d %s", response.status_code, response.reason)
        raise RuntimeError("Failed to download ExploitDB CSV")
    iterator = codecs.iterdecode(response.iter_lines(), "utf8")
    return _load_from_iterator(iterator)


if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG)
    eid2exploit = load_from_url()
    # eid2exploit = load_from_csv("tests/files_exploits.csv")
